## JavaScript专题

### call和apply和bind

#### call

```` javascript
Function.prototype.myCall = function (context = window, ...args) {
    if (typeof this !== 'function') {
        throw new TypeError('is not function')
    }
    const fn = Symbol()
    context[fn] = this
    let res = context[fn](...args)
    delete context[fn]
    return res
}
````

#### apply

```` javascript
Function.prototype.myApply = function (context = window, args = []) {
    if (typeof this !== 'function') {
        throw new TypeError('is not function')
    }
    const fn = Symbol()
    context[fn] = this
    let res = context[fn](...args)
    delete context[fn]
    return res
}
````

#### bind

```` javascript
Function.prototype.myBind = function (context = window, ...args1) {
    if (typeof this !== 'function') {
        throw new TypeError('is not function')
    }
    const _this = this
    return function F(...args2) {
        if (this instanceof F) {
            return new _this(...args1, ...args2)
        } else {
            return _this.apply(context, [...args1, ...args2])
        }
    }
}
````

### 防抖和节流

#### 防抖

```` javascript
function f(fn, wait = 50) {
    let timer
    return function (...args) {
        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(this, args)
        }, wait)
    }
}
````

#### 节流

```` javascript
function f(fn, wait = 50) {
    let lastTime = 0
    return function (...args) {
        const nowTime = +new Date()
        if (nowTime - lastTime >= 50) {
            lastTime = nowTime
            fn.apply(this, args)
        }
    }
}
````

#### 结合版

```` javascript
function fff(fn, wait = 50) {
    let lastTime = 0
    let timer
    return function (...args) {
        if (nowTime - lastTime >= 50) {
            clearTimeout(timer)
            timer = null
            lastTime = nowTime
            fn.apply(this, args)
        } else if (!timer) {
            timer = setTimeout(() => {
                fn.apply(this, args)
            }, wait)
        }
    }
}
````

### 深拷贝和浅拷贝

#### 浅拷贝

1.

```` javascript
function clone(obj) {
    let obj2 = Object.create(null)
    for (const key in obj) {
        obj2[key] = obj[key]
    }
    return obj2
}
````

2.

```` javascript
let obj1 = { ...obj }
````

3.

```` javascript
let obj2 = Object.assign({},obj1)
````

#### 深拷贝

1.

```` javascript
function deepClone(obj){
    return JSON.parse(JSON.stringify(obj))
}
````

2.

```` javascript
function isObject(obj) {
    const {
        toString
    } = Object.prototype
    return toString.call(obj) === '[object Object]' || toString.call(obj) === '[object Array]'
}

function deepClone(obj) {
    if (isObject(obj)) {
        let o = Array.isArray(obj) ? [] : {}
        for (const key in obj) {
            if (isObject(obj[key])) {
                o[key] = deepClone(obj[key])
            } else {
                o[key] = obj[key]
            }
        }
        return o
    } else {
        return obj
    }
}
````

### 数组扁平化

1.

```` javascript
function flat(arr) {
    let res = []
    for (const i of arr) {
        if (Array.isArray(i)) {
            res = res.concat(flat(i))
        } else {
            res.push(i)
        }
    }
    return res
}
````

2.

```` javascript
function flat(arr) {
    return arr.reduce((pre, cur) => {
        return Array.isArray(cur) ? [...pre, ...flat(cur)] : [...pre, cur]
    }, [])
}

function flat(arr) {
        return arr.reduce((pre, cur) => {
            return Array.isArray(cur) ? pre.concat(flat(cur)) : pre.concat(cur)
        }, [])
}
````

3.

```` javascript
function flat(arr) {
        // 去掉双引号 得到一个"1,2,3,4,5,6"的字符串
        let str = JSON.stringify(arr).replace(/(\[|\])/g, '')
        return str.split(',').map(key => key - 0)
}

````

4.

```` javascript
const arr = [1, [2, [3, 4]]];
function flatten(arr) {
    return arr.toString().split(',');
}
console.log(flatten(arr)); //  [1, 2, 3, 4]
````

5.

```` javascript
const arr = [1, [2, [3, 4]]];
function flatten(arr) {
  return arr.flat(Infinity);
}
console.log(flatten(arr)); //  [1, 2, 3, 4，5]
````



### 模拟map和filter

#### 模拟map

1.

```` javascript
// map的参数 current当前正在处理的元素，index索引,array,当前数组
// 返回一个新数组
Array.prototype.myMap = function (handler) {
    return this.reduce((target, current, index,array) => {
        target.push(handler.call(this, current, index,array))
        return target
    }, [])
}
````

2.

```` javascript
Array.prototype.myMap = function (hanler) {
    let res = []
    // this指向调用的数组
    for (let i = 0; i < this.length; i++) {
        res.push(hanler(this[i], i, this))
    }
    return res
}
````

#### 模拟filter

1.

```` javascript
// map的参数 current当前正在处理的元素，index索引,array,当前数组 
// 返回过滤后的数组
 Array.prototype.reduceToFilter = function (handler) {
        return this.reduce((target, current, index, array) => {
            // 如果满足传入的函数
            if (handler.call(this, current, index, array)) {
                target.push(current)
            }
            return target
        }, [])
}
````

2.

```` javascript
Array.prototype.myFilter = function (hanler) {
    let res = []
    for (let i = 0; i < this.length; i++) {
        if (hanler(this[i], i, this)) {
            res.push(this[i])
        }
    }
    return res
}
````

### async实现promise.all

```` javascript
用async实现promise.All
async function asyncAlls(jobs) {
    try {
        let results = jobs.map(async job => await job)
        let res = []
        for (const result of results) {
            res.push(await result)
        }
        return res
    } catch (error) {
        throw new Error(error)
    }
}
````



### 模拟fill

1.

```` javascript
//array.fill(value, start, end)
//value 必需。填充的值。start 可选。开始填充位置。end 可选。停止填充位置 (默认为 array.length)
Array.prototype.myFill = function (target, start = 0, end = arr.length) {
    for (let i = start; i < end; i++) {
        this[i] = target
    }
}
````

### 模拟实现Array.find()、Array.findIndex()

#### 模拟find

1.

```` javascript
// find() 方法返回数组中满足提供的测试函数的第一个元素的值。 否则返回 undefined
Array.prototype.myfind = function (fn, start = 0, end = this.length) {
    for (let i = start; i < end; i++) {
        if (fn.call(this, this[i], i, this)) {
            return this[i]
        }
    }
}
````

#### 模拟findIndex

```` javascript
// findIndex() 方法返回数组中满足提供的测试函数的第一个元素的索引。 否则返回 -1
Array.prototype.myFindIndex = function (fn, start = 0, end = this.length) {
    for (let i = start; i < end; i++) {
        if (fn.call(this, this[i], i, this)) {
            return i
        }
    }
     return -1
}
````

### 模仿promise

#### TypeScript版

```` typescript
type PromiseState = 'pending' | 'resolved' | 'rejected'

interface PromiseResolve<T> {
    (value: T): void
}
interface PromiseReject<T> {
    (value: T): void
}

interface MyPromiseMethod<T> {
    then: (onFulfilled: any, onRejected: any) => void
    all: (promises: MyPromise<T>) => any
    race: (promises: MyPromise<T>[]) => any
    reject: (reason: any) => any
    resolve: (value: any) => any
    catch: (error: any) => any
    finally: (fn: any) => any
}

class MyPromise<T> implements MyPromiseMethod<T> {
    state: PromiseState
    value: T
    reason: T
    successCb: PromiseResolve<T>[]
    failCb: any[]
    constructor(exec) {
        this.state = 'pending'
        this.value = null
        this.reason = null
        this.successCb = []
        this.failCb = []
        const resolve: PromiseResolve<T> = (value: T) => {
            if (this.state === 'pending') {
                this.value = value
                this.state = 'resolved'
                this.successCb.forEach((fn) => { fn(value) })
            }
        }
        const reject: PromiseReject<T> = (reason: T) => {
            if (this.state === 'pending') {
                this.reason = reason
                this.state = 'rejected'
                this.failCb.forEach((fn) => { fn(reason) })
            }
        }
        try {
            exec(resolve, reject)
        } catch (e) {
            reject(e)
        }
    }
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value
        onRejected = typeof onRejected === 'function' ? onRejected : reason => reason
        if (this.state === 'pending') {
            this.successCb.push(onFulfilled)
            this.failCb.push(onRejected)
        }
        if (this.state === 'resolved') {
            onFulfilled(this.value)
        }
        if (this.state === 'rejected') {
            onFulfilled(this.reason)
        }
    }
    all(promise) {
        let count = 0
        let res = []
        return new MyPromise((resolve, reject) => {
            for (let i = 0; i < promise.length; i++) {
                (promise[i] as MyPromise<T>).then(value => {
                    res.push(value)
                    count++
                    if (count === promise.length) {
                        resolve(res)
                    }
                }, e => {
                    reject(e)
                })
            }
        })
    }
    race(promise) {
        return new MyPromise((resolve, reject) => {
            for (let i = 0; i < promise.length; i++) {
                (promise[i] as MyPromise<T>).then(value => {
                    resolve(value)
                }, e => {
                    reject(e)
                    return
                })
            }
        })
    }
    static reject(reason) {
        return new MyPromise((resolve, reject) => {
            reject(reason)
        })
    }
    static resolve(value) {
        return new MyPromise((resolve, reject) => {
            resolve(value)
        })
    }
    catch(onRejected) {
        return this.then(null, onRejected)
    }
    finally(fn) {
        this.then((value) => {
            fn()
            return value
        }, err => {
            fn()
            return err
        })
    }
}
function testPromise(value) {
    return new MyPromise((resolve, reject) => {
        setTimeout(() => {
            if (value > 5) {
                resolve('大于5')
            } else {
                reject('小于等于5')
            }
        }, 50)
    })
}
function testPromise2(value) {
    return new MyPromise((resolve, reject) => {
        setTimeout(() => {
            if (value > 5) {
                resolve('大于5')
            } else {
                reject('小于等于5')
            }
        }, 50)
    })
}
MyPromise.prototype.all([testPromise2(11), testPromise(10)]).then(value => {
    console.log(value)
}, e => { console.log(e) })

````

#### JavaScript版本

```` javascript

````



### 模拟AJAX

```` javascript
function ajax(config: AjaxConfig) {
    return new Promise((resolve, reject) => {
        const { data = null, url, method = 'Get' } = config
        const request = new XMLHttpRequest()
        request.open(method, url, true)
        request.onreadystatechange = function () {
            if (request.readyState === 4 && request.status === 200) {
                resolve(request.responseText);
            } else {
                reject(request.statusText)
            }
        }
        request.send(JSON.stringify(data))
    })
}
````

### 模拟new的过程

1.

```` javascript
function myNew(fn, ...args) {
        //创建一个新对象，将新对象的__proto__ 指向构造函数的原型
        let obj = Object.create(fn.prototype)
        let res = fn.apply(obj, args)
        return res instanceof Object ? res : obj
}
````

### 模拟实现Object.create方法

1.

```` javascript
// 用于创建一个新对象,被创建的对象继承另一个对象(o)的原型
function create(obj) {
    function F() { }
    F.prototype = obj
    return new F()
}
````

### 模拟实现instanceof的功能 

1.

```` javascript
function myInstanceof(obj, F) {
    while (obj.__proto__) {
        if (obj.__proto__ === F.prototype) {
            return true
        }
        obj = obj.__proto__
    }
    return false
}
````

### 使用setTimeout实现setInterval方法 

1.

```` javascript
function recursive(fn, wait = 4000) {
      setTimeout(function () {
        fn()
        recursive(fn, wait) //递归，每隔4秒调用一次recursive()
      }, wait)
}
````

### 实现JSONP

```` javascript
//https://sp0.baidu.com/su?wd=Java&cb=cb';
function jsonP(url) {
    let script = document.createElement('script')
    script.scr = url
    document.body.appendChild(script)
}
function cb(value) {
    console.log(value)
}

````

###  promise 实现sleep函数

```` javascript
function sleep(wait = 50){
   return  new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve()
        }, wait)
    })
}
````

### 单例模式

```` typescript
class Person {
    static instance: null | Person
    private name: string
    private age: string
    constructor(name, age) {
        this.name = name
        this.age = age
    }
    static createPerson(name, age) {
        if (!Person.instance) {
            Person.instance = new Person(name, age)
        }
        return Person.instance
    }
}
````

### 发布订阅模式

```` javascript
class Watcher {
    constructor() {
        this.subs = []
    }
    on(eventName, fn) {
        if (this.subs[eventName]) {
            this.subs[eventName].push(fn)
        } else {
            this.subs[eventName] = [fn]
        }
    }
    emit(eventName, ...args) {
        if (Array.isArray(this.subs[eventName])) {
            this.subs[eventName].forEach(fn => {
                fn.apply(this, args)
            })
        }
    }
    unbind(eventName, fn) {
        if (fn) {
            this.subs[eventName] = this.subs[eventName].filter((e) => e !== fn && e.orgin !== fn)
        } else {
            delete this.subs[eventName]
        }
    }
    once(eventName, fn) {
        let only = (...args) => {
            fn.apply(this, args)
            this.unbind(eventName, fn)
        }
        only.orgin = fn
        this.on(eventName, only)
    }
}
````



### 数组乱序

1.

```` javascript
function random(arr) {
    let len = arr.length
    let current = len - 1
    while (current > -1) {
        let randomNum = Math.floor(Math.random() * len);
        [arr[current], arr[randomNum]] = [arr[randomNum], arr[current]]
        current--
    }
    return arr
}
````

2.

```` javascript
function random(arr) {
    return arr.sort(() => .5 - Math.random())
}
````

### 函数柯里化

```` javascript
 function add(...args) {
     let res = [...args]
     
     let adder = (...args2) => {
         res.push(...args2)
         return adder
     }
     
     adder.toString = function () {
         return res.reduce((pre, current) => pre + current, 0)
     }
     
     return adder
}
````

### 异步循环打印

```` javascript
 `打印10个10`	
 for (var i = 0; i < 10; i++) {
     setTimeout(() => {
         console.log(i)
     }, 0)
 }
````

1.利用let限制作用域

2.利用闭包保存变量

```` javascript
(function (j) {
    setTimeout(() => {
        console.log(j)
    }, 0)
})(i)
````

3.利用定时器的第三个参数

```` javascript
 `第三个参数会被当成第一个函数的参数`	
 for (var i = 0; i < 10; i++) {
     setTimeout((j) => {
         console.log(j)
     }, 0, i)
 }
````



### 实现继承

#### 原型链继承

```` javascript
`缺点 1.创建子类实例时，无法向父类构造函数传参 2.共享父类引用类型对象`
function Father() {

}
Father.prototype.sayHi = function () {
    return `说 Hi`
}

function Son(age) {
    this.age = age
}

Son.prototype = new Father()

const son = new Son(15)
````

#### 构造函数继承

```` javascript
	`缺点 1.无法继承父类的原型`
function Father(name) {
        this.name = name
}
Father.prototype.sayHi = function () {
    return `说 Hi`
}

function Son(name, age) {
    Father.call(this, name)
    this.age = age
}

const son = new Son('zs',15)
````

#### 组合继承

```` javascript
`缺点 1.调用两次构造函数，浪费内存`
function Father(name) {
    this.name = name
}

Father.prototype.sayHi = function () {
    return `${this.name} 说 Hi`
}

function Son(name, age) {
    Father.call(this, name)
    this.age = age
}

Son.prototype = new Father()
const son = new Son('zs', 15)
````

#### 寄生式继承

```` javascript
function Father(name) {
    this.name = name
}
Father.prototype.sayHi = function () {
    return `${this.name} 说 Hi`
}

function Son(name, age) {
    Father.call(this, name)
    this.age = age
}

Son.prototype = Object.create(Father.prototype, {
    constructor: {
        value: Son
    }
})

const son = new Son('zs', 15)
````

#### Class继承

```` javascript
class Father {
    constructor(name) {
        this.name = name
    }
    sayHi() {
        console.log(`${this.name} Say Hi`)
    }
}


// 会自动继承父类的原型
class Son extends Father {
    constructor(name, age) {
        //使用super调用父类构造函数
        super(name)
        this.age = age
    }
}

const person = new Son('zs', 15)
person.sayHi()
````



### 插入大量DOM

```` javascript
		let container = document.querySelector('.container')

        const sum = 1000
        const num = 20
        const loop = Math.floor(sum / num)
        let count = 0

        function render() {
            const frag = document.createDocumentFragment()
            for (let i = 0; i < num; i++) {
                const div = document.createElement('div')
                div.innerHTML = `${Math.floor(count*Math.random())}`
                frag.appendChild(div)
            }
            container.appendChild(frag)
            if (++count !== loop) {
                looper()
            }
        }
        function looper() {
            requestAnimationFrame(render)
        }
        looper()
````



## 算法专题

### 数学

#### 斐波那契

1.

```` javascript
function f(n, res = []) {
    if (n < 2) {
        return n
    }
    return f(n - 1) + f(n - 2)
}
````

2.

```` javascript
对递归进行优化，保存上一次的值
function f(n, res = []) {
    if (n < 2) {
        return n
    }
    return res[n]= res[n] ? res[n] : f(n - 1) + f(n - 2)
    // return res[n] ?? f(n - 1) + f(n - 2) 
}
````

3.

```` javascript
// 减少递归次数
function f(n) {
    if (n < 2) {
        return n
    }
    let arr = [1, 1]
    for (let i = 2; i < n; i++) {
        arr[i] = arr[i - 1] + arr[i - 2]
    }
    return arr[n - 1]
}
````

4.

```` javascript
// 优化空间问题
function f(n) {
    if (n < 2) {
        return n
    }
    let pre = 1
    let cur = 1
    let sum = 0
    for (let i = 2; i < n; i++) {
        sum = pre + cur
        pre = cur
        cur = sum
    }
    return sum
}

````

5.

```` javascript
// 利用尾递归优化
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) { return ac2 };

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}
````



### 链表



#### 反转链表

``` typescript
反转一个单链表。
示例:
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL  

function reverseList(head: ListNode | null): ListNode | null {
    let pre = null
    let next = null
    while (head) {
        next = head.next
        head.next = pre
        pre = head
        head = next
    }
    return pre
};
```

#### 判断是否有环

1.快慢指针

```` javascript
判断给定的链表中是否有环。如果有环则返回true，否则返回false。
// 快慢指针法，一个走2布，一个走一步
function hasCycle(head){
	let p = head
    let q = head
    while(p!=null && p.next!=null){
        p = p.next.next
        q= q.next
        if(p==q){
            return true
        }
    }
    return false
}
````

2.set集合

```` javascript
// 循环head加入到集合中，然后判断set表中是否存在
var hasCycle = function (head) {
    if (head === null || head.next === null) {
        return false
    }
    const set = new Set()
    while (head) {
        if (set.has(head)) {
            return true
        }
        set.add(head)
        head = head.next
    }
    return false
};
````



#### 合并两个有序链表

```` json
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例 1：
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

示例 2：
输入：l1 = [], l2 = []
输出：[]

示例 3：
输入：l1 = [], l2 = [0]
输出：[0]
````

1.迭代法

```` javascript
我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。

var mergeTwoLists = function (l1, l2) {
    const dammy = new ListNode(0)
    let prev = dammy
    while (l1 && l2) {
        if (l1.val < l2.val) {
            prev.next = l1
            l1 = l1.next
        } else {
            prev.next = l2
            l2 = l2.next
        }
        prev = prev.next
    }
    prev.next = l1 ? l1 : l2
    return dammy.next
};
````

2.递归

```` javascript
如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。

var mergeTwoLists = function (l1, l2) {
    if (l1 === null) {
        return l2
    } else if (l2 === null) {
        return l1
    } else if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    } else {
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
    }
};
````

#### [相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```` json
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

图示两个链表在节点 c1 开始相交：

题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。
示例 1：

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
示例 2：

输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
示例 3：

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
````

1.hash表

```` javascript
首先遍历A链表，全部加入hash表中
然后遍历B链表，查看b链表是否在hash表中

var getIntersectionNode = function (headA, headB) {
    let set = new Set()
    while (headA) {
        // 遍历A链表，全部加入hash表中
        set.add(headA)
        headA = headA.next
    }
    while (headB) {
        // 遍历B链表，查看b链表是否在hash表中，就找到了
        if (set.has(headB)) {
            return headB
        }
        headB = headB.next
    }
    return null
};
````

2.双指针

```` javascript
只有当链表 \textit{headA}headA 和 \textit{headB}headB 都不为空时，两个链表才可能相交。因此首先判断链表 \textit{headA}headA 和 \textit{headB}headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 \text{null}null。

当链表 \textit{headA}headA 和 \textit{headB}headB 都不为空时，创建两个指针 \textit{pA}pA 和 \textit{pB}pB，初始时分别指向两个链表的头节点 \textit{headA}headA 和 \textit{headB}headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：

每步操作需要同时更新指针 \textit{pA}pA 和 \textit{pB}pB；

如果指针 \textit{pA}pA 不为空，则将指针 \textit{pA}pA 移到下一个节点；如果指针 \textit{pB}pB 不为空，则将指针 \textit{pB}pB 移到下一个节点。

如果指针 \textit{pA}pA 为空，则将指针 \textit{pA}pA 移到链表 \textit{headB}headB 的头节点；如果指针 \textit{pB}pB 为空，则将指针 \textit{pB}pB 移到链表 \textit{headA}headA 的头节点。

当指针 \textit{pA}pA 和 \textit{pB}pB 指向同一个节点或者都为空时，返回它们指向的节点或者 \text{null}null。

var getIntersectionNode = function (headA, headB) {
    let pA = headA
    let pB = headB
    while (headB !== headA) {
        if (headA === null) {
            headA = pB
        } else {
            headA = headA.next
        }
        if (headB === null) {
            headB = pA
        } else {
            headB = headB.next
        }
    }
    return headA
};
````





### 指针

#### 无重复字符的最长子串

```` typescript
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

function lengthOfLongestSubstring(s: string): number {
    let maxLength = 0
    //存放最长子字符串的
    let arr = []
    for (let i of s) {
        // 查看是否有重复的
        let index = arr.indexOf(i)
        if (index !== -1) {
            //有的话，去除重复的字符串
            arr.splice(0, index + 1)
        }
        arr.push(i)
        maxLength = Math.max(maxLength, arr.length)
    }
    return maxLength
};
````

### 数组

#### 两数之和

##### 介绍

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
你可按任意顺序返回答案。
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1]

1.暴力破解，使用双循环

```` javascript
var twoSum = function (nums, target) {
    for (let i = 0; i < nums.length; i++) {
        let t = target - nums[i]
        for (let j = 0; j < nums.length; j++) {
            if (nums[j] === t && j !== i) {
                return [i, j]
            }
        }
    }
    return []
};
````

2.使用map

```` typescript
var twoSum = function (nums, target) {
    let map = new Map()
    for (let i = 0; i < nums.length; i++) {
        let t = target - nums[i]
        if (map.has(t)) {
            return [map.get(t), i]
        } else {
            map.set(nums[i], i)
        }
    }
    return []
};
````

#### [最大连续 1 的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)

````javascript
给定一个二进制数组， 计算其中最大连续 1 的个数。
示例：
输入：[1,1,0,1,1,1]
输出：3
解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.


/**
 * @param {number[]} nums
 * @return {number}
 */
var findMaxConsecutiveOnes = function (nums) {
    let max = 0;
    let current = 0;
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === 1) {
            current++;
            if (i === nums.length - 1) {
                 max = Math.max(max, current);
            }
        } else {
            max = Math.max(max, current);
            current = 0;
        }
    }
    return max;
};
````

#### [移动零](https://leetcode-cn.com/problems/move-zeroes/)

```` javascript
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:
必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。

双指针
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
    let i = 0,
        j = 0,
        n = nums.length;
    while (j < n) {
        if(nums[j]){
            [nums[i], nums[j]] = [nums[j], nums[i]];
            i++;
        }
        j++;
    }
    return nums;
};
````

### 动态规划

#### 最大子序列和

```` json
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [0]
输出：0
示例 4：

输入：nums = [-1]
输出：-1
示例 5：

输入：nums = [-100000]
输出：-100000


提示：

1 <= nums.length <= 3 * 104
-105 <= nums[i] <= 105
````

1.暴力破解法

```` typescript
function maxSubArray(nums: number[]): number {
    let max = -1000000
    for (let i = 0; i < nums.length; i++) {
        let sum = 0;
        for (let j = i; j < nums.length; j++) {
            sum += nums[j]
            max = Math.max(max, sum)
        }
    }
    return max
};
````

2.动态规划

```` typescript
function maxSubArray(nums: number[]): number {
    let pre = 0,
        maxAns = nums[0]
    for (let num of nums) {
        如果前边累加后还不如自己本身大，那就把前边的都扔掉，从此自己本身重新开始累加。
        pre = Math.max(num, pre + num)
        maxAns = Math.max(pre,maxAns)
    }
    return maxAns
};
````

### 二叉树

#### [二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```` json
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层序遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
````

1.广度优先搜索

```` javascript
我们可以用广度优先搜索解决这个问题。

我们可以想到最朴素的方法是用一个二元组 (node, level) 来表示状态，它表示某个节点和它所在的层数，每个新进队列的节点的 level 值都是父亲节点的 level 值加一。最后根据每个点的 level 对点进行分类，分类的时候我们可以利用哈希表，维护一个以 level 为键，对应节点值组成的数组为值，广度优先搜索结束以后按键 level 从小到大取出所有值，组成答案返回即可。

var levelOrder = function (root) {
    const res = []
    if (!root) {
        return res
    }
    const q = []
    q.push(root)
    while (q.length !== 0) {
        const currentLength = q.length
        res.push([])
        for (let i = 0; i < currentLength; i++) {
            const node = q.shift()
            res[res.length - 1].push(node.val)
            if(node.left) q.push(node.left)
            if(node.right) q.push(node.right)
        }
    }
    return res
};
````



### 字符串

#### 字符串相加

```` json
给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。
提示：
num1 和num2 的长度都小于 5100
num1 和num2 都只包含数字 0-9
num1 和num2 都不包含任何前导零
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式
````

```` javascript
本题我们只需要对两个大整数模拟「竖式加法」的过程。竖式加法就是我们平常学习生活中常用的对两个整数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位相加，如果当前位和超过 1010，则向高位进一位？因此我们只要将这个过程用代码写出来即可。


具体实现也不复杂，我们定义两个指针i和j分别指向nums1和nums2的末尾，即最低位，同时定义一个变量 add维护当前是否有进位，然后从末尾到开头逐位相加即可。你可能会想两个数字位数不同怎么处理，这里我们统一在指针当前下标处于负数的时候返回 0，等价于对位数较短的数字进行了补零操作，这样就可以除去两个数字位数不同情况的处理，具体可以看下面的代码。

var addStrings = function (num1, num2) {
    let i = num1.length - 1
    let j = num2.length - 1
    let add = 0
    let res = []
    while (i >= 0 || j >= 0 || add !== 0) {
        let x = i >= 0 ? num1[i] - 0 : 0
        let y = j >= 0 ? num2[j] - 0 : 0
        let r = add + x + y
        res.unshift(r % 10)
        add = Math.floor(r / 10)
        j--
        i--
    }
    return res.join('')
};
````

#### 统计出现最多的字符

```` javascript
function sumMax(str) {
            const map = new Map()
            for (const s of str) {
                if (map.has(s)) {
                    map.set(s, map.get(s) + 1)
                } else {
                    map.set(s, 1)
                }
            }
            let max = {
                value: -1,
                key: null
            }
            for (const [key, value] of map.entries()) {
                if (value > max.value) {
                    max.value = value
                    max.key = key
                }
            }
            return max.key
        }
````

### 指针

#### 三数之和

```` json
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 

示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
示例 2：

输入：nums = []
输出：[]
示例 3：

输入：nums = [0]
输出：[]

````

```` typescript
排序+双指针

题目中说明可能会出现多组结果，所以我们要考虑好去重

1.为了方便去重，我们首先将数组排序
2.对数组进行遍历，取当前遍历的数nums[i]为一个基准数，遍历数后面的数组为寻找数组
3.在寻找数组中设定两个起点，最左侧的left(i+1)和最右侧的right(length-1)
4.判断nums[i] + nums[left] + nums[right]是否等于0，如果等于0，加入结果，并分别将left和right移动一位
5.如果结果大于0，将right向左移动一位，向结果逼近
5.如果结果小于0，将left向右移动一位，向结果逼近
注意整个过程中要考虑去重

var threeSum = function (nums) {
      const result = [];
      nums.sort((a, b) => a - b);
      for (let i = 0; i < nums.length; i++) {
        // 跳过重复数字
        if (i && nums[i] === nums[i - 1]) { continue; }
        let left = i + 1;
        let right = nums.length - 1;
        while (left < right) {
          const sum = nums[i] + nums[left] + nums[right];
          if (sum > 0) {
            right--;
          } else if (sum < 0) {
            left++;
          } else {
            result.push([nums[i], nums[left++], nums[right--]]);
            // 跳过重复数字
            while (nums[left] === nums[left - 1]) {
              left++;
            }
            // 跳过重复数字
            while (nums[right] === nums[right + 1]) {
              right--;
            }
          }
        }
      }
      return result;
    }
````

#### [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

1.暴力破解法

```` javascript
var maxProfit = function (prices) {
    let maxProfit = 0
    for (let i = 0; i < prices.length - 1; i++) {
        for (let j = i + 1; j < prices.length; j++) {
            if (prices[j] - prices[i] > maxProfit) {
                maxProfit = prices[j] - prices[i]
            }
        }
    }
    return maxProfit
};
````

2.一次遍历

```` javascript
显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。

因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。
	
var maxProfit = function (prices) {
    let maxProfit = 0
    let min = Number.MAX_SAFE_INTEGER

    for (let i = 0; i < prices.length; i++) {
        if (prices[i] < min) {
            min = prices[i]
        } else if (prices[i] - min > maxProfit) {
            maxProfit = prices[i] - min
        }
    }
    return maxProfit
};
````



### 排序算法

#### 冒泡排序

```` javascript
function sort(arr) {
    let len = arr.length
    for (let i = 0; i < len - 1; i++) {
        let flag = true
        for (let j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
                flag = false
            }
        }
        if (flag) {
            return arr
        }
    }
    return arr
}
````

#### 选择排序

```` typescript
function sort<T>(arr: T[]): T[] {
    let len = arr.length
    for (let i = 0; i < len - 1; i++) {
        let current = i
        for (let j = i + 1; j < len; j++) {
            if (arr[current] > arr[j]) {
                current = j
            }
        }
        if (current !== i) {
            [arr[i], arr[current]] = [arr[current], arr[i]]
        }
    }
    return arr
}
````

#### 快速排序

```` typescript
function sort<T>(arr: T[], start: number = 0, end: number = arr.length - 1): T[] {
    if (end - start < 1) {
        return arr
    }
    const target = arr[start]
    let left = start
    let right = end
    while (left < right) {
        while (left < right && arr[right] >= target) {
            right--
        }
        arr[left] = arr[right]
        while (left < right && arr[left] < target) {
            left++
        }
        arr[right] = arr[left]
    }
    arr[left] = target
    sort(arr, start, left - 1)
    sort(arr, left + 1, end)
    return arr
}
````

### 查找算法

#### 二分查找

```` javascript
//二分查找的条件是必须是有序的线性表。
function search(data, arr, start, end) {
    if (start > end) {
        return -1;
    }
    const center = Math.floor((end + start) / 2);
    if (data === arr[center]) {
        return center
    } else if (data < arr[center]) {
        return search(data, arr, start, center - 1)
    } else {
        return search(data, arr, center + 1, end)
    }
    return -1;
}
````



## CSS

### 三列布局

1.利用calc计算属性

```` css
.container>div {
    height: 100px;
}

.container>div:nth-child(1) {
    float: left;
    width: 200px;
    background-color: red;
}

.container>div:nth-child(2) {
    float: left;
    width: calc(100vw - 500px);
    background-color: blue;
}

.container>div:nth-child(3) {
    float: left;
    width: 300px;
    background-color: yellow;
}
````

2.grid布局

``` css
.container {
    display: grid;
    /* 列的数量和宽度 */
    grid-template-columns: 200px auto 300px;
    /* 行的数量和高度 */
    grid-template-rows: 100px;
    height: 100vh;
    background-color: #000;
}
```

3.flex布局

``` css
.container {
    display: flex;
    height: 100vh;
    background-color: #000;
}

.container>div {
    height: 100px;
}

.container>div:nth-child(1) {
    width: 200px;
    background-color: red;
}

.container>div:nth-child(2) {
    flex: 1;
    background-color: blue;
}

.container>div:nth-child(3) {
    width: 300px;
    background-color: yellow;
}
```

4.定位布局

```` css
	父元素相对定位，子元素绝对定位，第一个和最后一个left:0,right:0,中间的left第一个宽度，right右边的宽度
.container {
    position: relative;
    height: 100vh;
    background-color: #000;
}

.container>div {
    height: 100px;
}

.container>div:nth-child(1) {
    position: absolute;
    left: 0;
    width: 200px;
    background-color: red;
}

.container>div:nth-child(2) {
    position: absolute;
    left: 200px;
    right: 300px;
    background-color: blue;
}

.container>div:nth-child(3) {
    position: absolute;
    right: 0;
    width: 300px;
    background-color: yellow;
}
````

5.table布局

```` css
父元素设置table   子元素设置table-cell
.container {
    display: table;
    width: 100vw;
    background-color: #000;
}

.container>div {
    height: 100px;
}

.container>div:nth-child(1) {
    display: table-cell;
    width: 200px;
    background-color: red;
}

.container>div:nth-child(2) {
    background-color: blue;
}

.container>div:nth-child(3) {
    display: table-cell;
    width: 300px;
}
````



### 垂直水平居中

1.父元素相对定位，子元素绝对定位，已知宽高下走自己的负一半

``` css
.container div:first-child {
     position: absolute;
     top: 50%;
     left: 50%;
     width: 200px;
     height: 200px;
     margin-left: -100px;
     margin-top: -100px;
     background-color: #fff;
}
```

2.父元素相对定位，子元素绝对定位，已知宽高下利用calc计算属性

```` css
.container div:first-child {
    position: absolute;
    top: calc(50% - 100px);
    left: calc(50% - 100px);
    width: 200px;
    height: 200px;
    background-color: #fff;
 }
````

3.父元素相对定位，子元素绝对定位，未知宽高下利用translate属性

```` css
.container div:first-child {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 200px;
    height: 200px;
    transform: translate(-50%,-50%);
    background-color: #fff;
}
````

4.利用flex布局,子元素设置auto

````css
.container {
    display: flex;
    height: 100vh;
    width: 100vw;
    background-color: #000;
}

.container div:first-child {
    margin: auto;
    width: 200px;
    height: 200px;
    background-color: #fff;
}
````

5.利用flex布局,设置主轴和交叉轴对齐方向

```` css
  .container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      width: 100vw;
      background-color: #000;
}
````

6.利用绝对定位,四个角都设置0,margin：auto即可

```` css
 .box {
     position: absolute;
     top: 0;
     left: 0;
     bottom: 0;
     right: 0;
     margin: auto;
     width: 200px;
     height: 200px;
     background-color: red;
 }
````

7.利用grid布局,子元素margin：auto即可

```` css
.f {
    display: grid;
    width: 100vw;
    height: 100vh;
}

.c {
    width: 100px;
    height: 100px;
    margin: auto;
    border: 1px solid red;
}

````

## VUE

### 手写简易版vue

https://segmentfault.com/a/1190000019884386

#### html

```` html
<style>
    #app{
        border: 1px solid red;
        margin: 10px;
        padding: 20px;
    }
</style>
<body>
    <div id="app">
        <input type="text" v-modal="name">
        <div class="outer">
            <span>{{name}}</span>
            <p><span v-html="name"></span></p>
        </div>
        <button @click="reset">重置</button>
    </div>
</body>
<script src="./wvue.js"></script>
<script>
    //  阶段一
    const data = {
        el: '#app',
        data: {
            name: '米粒'
        },
        methods: {
            reset() {
                this.name = ''
            }
        },
    }
    const app = new Wvue(data)
</script>
````

#### js

```` javascript
class Wvue {
    constructor(option) {
        this.$option = option
        this.$data = option.data
        this.$methods = option.methods
        this.observer(this.$data)
	    new Compile(option.el, this)
    }
    observer(obj) {
        if (!obj || typeof obj !== "object") {
            return;
        }
        console.log('observer')
        Object.keys(obj).forEach(key => {
            this.defineProperty(obj, key, obj[key])
            this.proxyObj(key)
        })
    }
    defineProperty(obj, key, val) {
        this.observer(val)
        //---------------- 新增为每一个变量都创建管理watcher的Dep实例
        const dep = new Dep()
        Object.defineProperty(obj, key, {
            get() {
                console.log('defineProperty获取')
                // 每次访问name 都会创建一个watcher，并加入到Dep中
                Dep.target !== null && dep.addDep(Dep.target)
                return val
            },
            set(newVal) {
                console.log('defineProperty更新了', newVal)
                val = newVal
                dep.notify()
            }
        })
    }

    proxyObj(key) {
        Object.defineProperty(this, key, {
            get() {
                console.log('proxyObj获取')
                return this.$data[key]
            },
            set(newVal) {
                console.log('proxyObj更新', newVal)
                this.$data[key] = newVal
            }
        })
        
    }
}
// -----------新增Watcher类 用于根据通知触发绑定的回调函数
class Watcher {
    constructor(vm, key ,cb) {
        this.$vm = vm
        this.$key = key
        this.$cb = cb
        // 用一个全局变量来指代当前watch
        Dep.target = this
        console.log('Watcher-------')
        // 实际是访问了this.name，触发了当前变量的get，
        // 当前变量的get会收集当前Dep.target指向的watcher,即当前watcher
        this.$vm[this.$key]
        Dep.target = null

    }
    update() {
        // 执行
        this.$cb.call(this.$vm, this.$vm[this.$key])
    }
}
// -----------新增Dep类 用于收集watcher
class Dep {
    constructor() {
        this.dep = []
    }
    addDep(dep) {
        console.log('addDep')
        this.dep.push(dep)
    }
    notify() {
        // 通知所有的watcher执行更新
        this.dep.forEach(watcher => {
            watcher.update()
        })
    }
}



````

#### Compile

```` javascript
class Compile {
    constructor(el, vm) {
        this.$vm = vm
        // $el挂载的就是需要处理的DOM
        this.$el = document.querySelector(el)
        // 将真实的DOM元素拷贝一份作为文档片段，之后进行分析
        const fragment = this.node2Fragment(this.$el)
        // 解析文档片段
        this.compileNode(fragment)
        // 将文档片段加入到真实的DOM中去
        this.$el.appendChild(fragment)
    }
    // https://developer.mozilla.org/zh-CN/search?q=querySelector
    // https://developer.mozilla.org/zh-CN/docs/Web/API/Node node对象
    node2Fragment(el) {
        // 创建空白文档片段
        const fragment = document.createDocumentFragment()
        let child
        //  appendChild会把原来的child给移动到新的文档中，当el.firstChild为空时，
        // while也会结束 a = undefined  => 返回 undefined
        while((child = el.firstChild)) {
            fragment.appendChild(child);
        }
        return fragment
    }
    // 通过迭代循环来找出{{}}中的内容，v-xxx与@xxx的内容，并且单独处理
    compileNode(node) {
        const nodes = node.childNodes
        // 类数组的循环
        Array.from(nodes).forEach(node => {
            if (this.isElement(node)) {
                this.compileElement(node)
            } else if (this.isInterpolation(node)) {
                this.compileText(node)
            }
            node.childNodes.length > 0 && this.compileNode(node)
        });
    }
    // https://developer.mozilla.org/zh-CN/docs/Web/API/Node  Node.nodeType
    isElement(node) {
        return node.nodeType === 1;
    } 
    // 校验是否是文本节点 并且是大括号中的内容
    isInterpolation(node) {
        return node.nodeType === 3 && /\{\{(.*)\}\}/.test(node.textContent)
    }
    compileText(node) {
        const reg = /\{\{(.*?)\}\}/g
        const string = node.textContent.match(reg)
        // 取出大括号中的内容，并且处理
        // RegExp.$1是RegExp的一个属性,指的是与正则表达式匹配的第一个 子匹配(以括号为标志)字符串
        // 以此类推，RegExp.$2，RegExp.$3，..RegExp.$99总共可以有99个匹配
        this.text(node, RegExp.$1)
    }
    compileElement(node) {
        const nodeAttrs = node.attributes;
        Array.from(nodeAttrs).forEach(arr => {
            if (arr.name.indexOf('v-') > -1) {
                this[`${arr.name.substring(2)}`](node, arr.value)
            }
            if (arr.name.indexOf('@') > -1) {
                // console.log(node, arr.value)
                this.eventHandle(node, arr.name.substring(1), arr.value)
            }
        })
    }
    // 因为是大括号里面的内容，所以沿用之前的逻辑，都加上watcher
    text(node, key) {
        new Watcher(this.$vm, key, () => {
            node.textContent = this.$vm[key]
        })
        // 第一次初始化界面， 不然如果不进行赋值操作，
        // 就不会触发watcher里面的回调函数
        node.textContent = this.$vm[key]
    }
    html(node, key) {
        new Watcher(this.$vm, key, () => {
            node.innerHTML = this.$vm[key]
        })
        node.innerHTML = this.$vm[key]
        
    }
    // 对@xxx事件的处理
    eventHandle(node, eventName, methodName) {
        node.addEventListener(eventName, () => {
            this.$vm.$methods[methodName].call(this.$vm)
        })
    }
    // v-modal的处理 不仅仅当赋值的时候回触发watcher，并且为input添加事件
    // input中的值去修改this.$data.$xxx的值，实现双向绑定
    modal(node, key) {
        console.log(node.value)
        new Watcher(this.$vm, key, () => {
            node.value = this.$vm[key]
        })
        node.value = this.$vm[key]
        node.addEventListener('input', (e) => {
            this.$vm[key] = e.target.value
        })
    }
}
````

